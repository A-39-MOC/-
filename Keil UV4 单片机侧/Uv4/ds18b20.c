#include <reg52.h>
#include "ds18b20.h"
#include "delay.h"

/*******************************************************************************
* 函 数 名         : ds18b20_init
* 函数功能		   : 18B20初始化
* 输    入         : void
* 输    出         : bit
*******************************************************************************/
bit ds18b20_init(void)
{
	uchar idx;
	DQ = 0;		 		//将总线拉低480us~960us
	delay_us(255);		//延时515us
	DQ = 1;				//然后拉高总线，如果DS18B20做出反应会将在15us~60us后总线拉低
	idx = 0;
	while(DQ)			//等待DS18B20拉低总线
	{
		delay_us(5);	//延时15us
		if(++idx>=10)	//等待>=150us
		{
			return 0;	//初始化失败
		}
	}
	delay_us(50);		//延时105us，注意：protues仿真无法读到数据极有可能是该延时问题，适当放大该延时时间
	return 1;			//初始化成功
}

/*******************************************************************************
* 函 数 名         : ds18b20_wr_byte
* 函数功能		   : 写入一个字节
* 输    入         : uchar dat
* 输    出         : void
*******************************************************************************/
void ds18b20_wr_byte(uchar dat)
{
	uchar idx;
	for(idx=0; idx<8; idx++)
	{
		DQ = 0;	    	//每写入一位数据之前先把总线拉低1us
		DQ = dat&0x01;	//然后写入一个数据，从最低位开始
		delay_us(29);	//延时63us
		DQ = 1;			//然后释放总线，至少1us给总线恢复时间才能接着写入第二个数值
		dat >>= 1;
	}
}

/*******************************************************************************
* 函 数 名         : ds18b20_re_byte
* 函数功能		   : 读取一个字节
* 输    入         : void
* 输    出         : uchar
*******************************************************************************/
uchar ds18b20_re_byte(void)
{
	uchar idx;
	uchar byte;
	for(idx=8;idx>0;idx--)
	{
		DQ = 0;			//先将总线拉低1us
		byte >>= 1;
		DQ = 1;			//然后释放总线
		delay_us(4);	//延时13us
		if(DQ)
		{
			byte |= 0x80;
		}
		delay_us(24);	//延时53us
	}
	return byte;
}

/*******************************************************************************
* 函 数 名         : ds18b20_temp_conver
* 函数功能		   : 温度转换命令
* 输    入         : void
* 输    出         : void
*******************************************************************************/
void ds18b20_temp_conver(void)
{
	if(ds18b20_init())
	{
		ds18b20_wr_byte(0xcc);	//跳过ROM操作命令		 
		ds18b20_wr_byte(0x44);	//温度转换命令
	}
}

/*******************************************************************************
* 函 数 名         : ds18b20_temp_read
* 函数功能		     : 温度读取命令
* 输    入         : void
* 输    出         : void
*******************************************************************************/
void ds18b20_temp_read(void)
{
	if(ds18b20_init())
	{
		ds18b20_wr_byte(0xcc);	//跳过ROM操作命令		 
		ds18b20_wr_byte(0xbe);	//温度转换命令
	}
}

/*******************************************************************************
* 函 数 名         : ds18b20_read_temp
* 函数功能		   : 读取温度
* 输    入         : void
* 输    出         : void
*******************************************************************************/
int ds18b20_read_temp(void)
{
	int temp;
	uchar tmh,tml;
	ds18b20_temp_read();
	tml = ds18b20_re_byte();		//读取温度值共16位，先读低字节
	tmh = ds18b20_re_byte();		//再读高字节
	temp = tmh;
	temp <<= 8;
	temp |= tml;
	return (int)(temp*0.625);
}

/*******************************************************************************
* 函 数 名         : ds18b20_temp_change
* 函数功能		   : 负温度数据转换
* 输    入         : int* tm
* 输    出         : void
*******************************************************************************/
void ds18b20_temp_change(int* tm)
{
	if(*tm < 0)				//当温度值为负数
	{
		*tm = *tm-1;		//把获得的数据（补码）减一取反求出原码
		*tm = ~(*tm);
	}
}
